#include "ServChannel.hpp"

size_t ServChannel::conn_cnt_ = 0;

long long aigetkey(const struct addrinfo *addrinfo) 
{
    const struct addrinfo *sorted[ADDRINFO_MAX];
    const struct addrinfo *p;
    MD5_CTX ctx; 
    unsigned char digest[16];
    int i, j;

    for (p = addrinfo, i = 0; p && i < ADDRINFO_MAX; p = p->ai_next, i++) 
    {    
        for (j = i; j > 0; j--) 
        {    
            if (__aicmp(p, sorted[j - 1]) < 0) 
                sorted[j] = sorted[j - 1];
            else 
                break;
        }    
        sorted[j] = p; 
    }    
    MD5_Init(&ctx);
    for (j = 0; j < i; j++) 
    {    
        MD5_Update(&ctx, sorted[j]->ai_addr,
                sorted[j]->ai_addrlen);
    }    
    MD5_Final(digest, &ctx);
    return *(long long *)digest;
}

struct addrinfo* ServChannel::__copy_addrinfo(struct addrinfo* addr)
{
    if(!addr)
        return NULL;
    unsigned sz = sizeof(struct addrinfo);
    if(ai->ai_family == AF_INET)
        sz += sizeof(struct sockaddr_in);
    else
        sz += sizeof(struct sockaddr_in6);
    struct addrinfo* cur_ai_copy = (struct addrinfo*)malloc(sz);
    memcpy(cur_ai_copy, addr, sz);
    return cur_ai_copy;
}

Connection* ServChannel::__create_connection(struct sockaddr* dst_addr, sockaddr* local_addr)
{
    if(conn_cnt_ >= MAX_CONN_NUM)
    {
        LOG_ERROR("connection exceed max num %d", MAX_CONN_NUM);
        return NULL; 
    }
    Connection* conn = (Connection*)malloc(sizeof(Connection)); 
    assert(conn); 
    INIT_LIST_HEAD(&conn->list);
    conn->state = CS_CLOSED;
    conn->error = 0;
    conn->scheme = DEFAULT_HTTP_SCHEME;
    conn->sockfd = -1;
    conn->message = NULL;
    conn->socket_family = AF_INET;
    conn->socket_type = SOCK_STREAM;
    conn->protocol = 0;
    conn->address.remote_addr = dst_addr;
    conn->address.remote_addrlen = sizeof(struct sockaddr);
    if(!local_addr)
    {
        conn->address.local_addr    = NULL;
        conn->address.local_addrlen = 0;
    }
    else
    {
        conn->address.local_addr = (struct sockaddr*)malloc(sizeof(struct sockaddr));
        memcpy(conn->address.local_addr, local_addr, sizeof(struct sockaddr));
        conn->address.local_addrlen = sizeof(struct sockaddr);
    }
    conn->ssl = NULL;
    conn->user_data = NULL;
    conn_cnt_ += 1;
    return conn;
}

ServChannel::ServChannel(struct addrinfo * ai, unsigned max_err_cnt, unsigned concurency_mode, struct sockaddr* local_addr):
    fetch_time_(0), is_foreign_(false), concurency_mode_(concurency_mode), 
    using_cnt_(0), max_err_rate_(max_err_cnt)
{
    if(local_addr)
    {
        local_addr_ = (struct sockaddr*)malloc(sizeof(struct sockaddr));
        memcpy(local_addr_);
        __copy_addrinfo(local_addr);
    }
    else
        local_addr_ = NULL;
    struct addrinfo * cur_ai = ai;
    while(!cur_ai)
    {
        Connection* conn = __create_connection(__copy_addrinfo(cur_ai), local_addr_);
        if(!conn)
            break;
        conn_storage_.push(conn);
        cur_ai = cur_ai->ai_next;
    }
}

~ServChannel::ServChannel()
{
    while(!conn_storage_.empty())
    {
        Connection * conn = conn_storage_.front();
        conn_storage_.pop();
        free(conn);
    }
}

void ServChannel::AddSucc()
{
    err_rate_.Add(0.0);
}

void ServChannel::AddFail()
{
    err_rate_.Add(1.0);
}

void ServChannel::AddRespTime(time_t resp_time)
{
    resp_time_.Add(resp_time); 
}

void ServChannel::SetForeign()
{
    is_foreign_ = true;
}

double ServChannel::GetAvgRespTime()
{
    return resp_time_.Average();
}

double ServChannel::GetSuccRate()
{
    return 1.0 - err_rate_.Average(); 
}

bool ServChannel::IsForeign()
{
    return is_foreign_;
}

bool ServChannel::IsServErr()
{
    return err_rate_.Average() > ;
} 

Connection* ServChannel::__acquire_connection(struct sockaddr* local_addr)
{
    Connection* conn = NULL;
    size_t cur_size = conn_storage_.size();
    switch(concurency_mode_)
    {
        case NO_CONCURENCY:
        {
            if(cur_size == 0 || using_cnt_ > 0)
            {
                conn = NULL;
                break;
            }
            //next follow with CONCURENCY_PER_SERV
        }
        case CONCURENCY_PER_SERV:
        {
            if(cur_size == 0)
            {
                conn = NULL;
                break;
            } 
            conn = conn_storage_.front();
            conn_storage_.pop();
            using_cnt_ += 1;
            break;
        }
        case CONCURENCY_NO_LIMIT:
        {
            assert(cur_size > 0);
            conn = conn_storage_.front();
            conn_storage_.pop();
            if(cur_size == 1)
            {
                Connection* new_conn = __create_connection(__copy_addrinfo(conn->address.remote_addr), local_addr);
                if(new_conn)
                    conn_storage_.push_back(new_conn);
                else
                {
                    conn_storage_.push_back(conn);
                }
            }
            break;
        }
        default:
        {
            assert(false);
        }
    }
    if(!conn->address.local_addr && local_addr)
        conn->address.local_addr = (sockaddr*)malloc(sizeof(struct sockaddr));
    if(conn->address.local_addr && local_addr)
        memcpy(conn->address.local_addr, local_addr, sizeof(struct sockaddr));
    if(!local_addr && conn->address.local_addr)
    {
        free(conn->address.local_addr);
        conn->address.local_addr    = NULL;
        conn->address.local_addrlen = 0;
    }
    return conn;
}

void ServChannel::__release_connection(Connection* conn)
{
    if(conn)
    {
        conn_storage_.push_back(conn);
        using_cnt_ -= 1;
    }
}

Resource* ServChannel::PopResource()
{
    Resource* p_res = NULL;
    if(this->res_lst_map_.empty())
        return p_res;
    ResPriorMap::iterator prior_map_it = this->res_lst_map_.begin();
    p_res = prior_map_it->pop_front();
    p_res->conn_ = conn;
    if(prior_map_it->is_empty())
        this->res_lst_map_.erase(prior_map_it);
    return p_res;
}

bool ServChannel::Empty()
{
    return this->res_lst_map_.begin().is_empty();
}

Resource* ServChannel::PopAvailableResource()
{
    if(Empty())
        return NULL;
    Connection* conn = __acquire_connection(p_res->local_addr_);
    if(!conn)
        return NULL;
    Resource* p_res = PopResource();
    assert(p_res);
    return p_res;
}

Resource* ServChannel::AddResource(Resource* res) 
{
    res_lst_map_[res->prior_].add(*res);
}

void ServChannel::RemoveResource(Resource* res)
{
    assert(res);
    ResPriorMap::iterator lst_map_it = res_lst_map_.find(res->prior_);
    if(lst_map_it != res_lst_map_.end()) 
        lst_map_it->del(*res);
    __release_connection(res->conn_);
    res->conn_ = NULL;
    delete res;
}
